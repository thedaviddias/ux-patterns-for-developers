const { promises: fs } = require("node:fs");
const path = require("node:path");

// Get the project root (where this script is located)
const PROJECT_ROOT = path.dirname(__dirname);
const REGISTRY_JSON_PATH = path.join(
	PROJECT_ROOT,
	"packages/registry/registry.json",
);
const OUTPUT_PATH = path.join(PROJECT_ROOT, "packages/registry/.generated");
const REGISTRY_PUBLIC_PATH = path.join(
	PROJECT_ROOT,
	"packages/registry/public/r",
);

async function buildRegistryIndex() {
	// Ensure output directory exists
	await fs.mkdir(OUTPUT_PATH, { recursive: true });

	// Read the registry.json file
	const registryContent = await fs.readFile(REGISTRY_JSON_PATH, "utf-8");
	const registry = JSON.parse(registryContent);

	// Filter for blocks that should be shown as examples
	// Exclude .d files which are TypeScript declaration files
	const blockComponents = registry.items.filter(
		(item) => item.type === "registry:block" && !item.name.endsWith(".d"),
	);

	// Generate index content
	let indexContent = `// This file is autogenerated by scripts/build-registry.js
// Do not edit this file directly.
import * as React from "react";

interface ComponentInfo {
  name: string;
  description: string;
  type: string;
  registryDependencies: string[];
  files: Array<{
    path: string;
    type: string;
    target: string;
  }>;
  component: React.LazyExoticComponent<React.ComponentType<any>>;
  source?: string;
  meta: {
    tags: string[];
  };
}

export const Index: Record<string, ComponentInfo> = {`;

	// Add the Index entries for each block component
	for (const component of blockComponents) {
		const componentName = component.name;
		const description = component.description || `${componentName} component`;

		// Use the actual file path from the registry, removing the file extension
		const firstFile = component.files?.[0];
		const componentPath = firstFile
			? `../${firstFile.path.replace(/\.(tsx?|jsx?)$/, "")}`
			: `../registry/default/blocks/${componentName}`;

		// Try to read the source code from the JSON file
		let sourceCode = null;
		try {
			const jsonPath = path.join(REGISTRY_PUBLIC_PATH, `${componentName}.json`);
			const jsonContent = await fs.readFile(jsonPath, "utf-8");
			const jsonData = JSON.parse(jsonContent);
			sourceCode = jsonData.files?.[0]?.content || null;
		} catch (error) {
			console.warn(
				`Could not read source for ${componentName}:`,
				error.message,
			);
		}

		indexContent += `
  "${componentName}": {
    name: "${componentName}",
    description: "${description}",
    type: "${component.type}",
    registryDependencies: ${JSON.stringify(component.registryDependencies || [])},
    files: [${component.files
			?.map((file) => {
				return `{
        path: "${file.path}",
        type: "${file.type}",
        target: "components/blocks/${componentName}.tsx"
      }`;
			})
			.join(", ")}],
    component: React.lazy(async () => {
      const mod = await import("${componentPath}") as any
      const keys = Object.keys(mod);
      const exportName = keys.find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object') || keys[0];
      return { default: mod.default || (exportName ? mod[exportName] : undefined) }
    }),${
			sourceCode
				? `
    source: ${JSON.stringify(sourceCode)},`
				: ""
		}
    meta: ${JSON.stringify(component.meta || {})},
  },`;
	}

	indexContent += `
};`;

	// Remove existing file first (like rimraf)
	try {
		await fs.unlink(path.join(OUTPUT_PATH, "index.tsx"));
	} catch (_error) {
		// File doesn't exist, that's fine
	}

	// Write the index file
	await fs.writeFile(
		path.join(OUTPUT_PATH, "index.tsx"),
		indexContent,
		"utf-8",
	);

	console.log(
		`âœ… Registry index built with ${blockComponents.length} components`,
	);
}

async function main() {
	try {
		console.log("Building registry...");
		await buildRegistryIndex();
		console.log("Registry build complete!");
	} catch (error) {
		console.error("Failed to build registry:", error);
		process.exit(1);
	}
}

main();
